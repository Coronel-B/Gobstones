program {
	return (hayNConsecutivasHacia(Norte, 4))
}

function puedeMoverHaciaN(d, n) {
	c := n
	while (puedeMover(d) && c > 0) {
		Mover(d)
		c := c - 1
	}
	return (c == 0)
}

function hayMismoColorHaciaN(d, n) {
	return (puedeMoverHaciaN(d, n) && hayMismoColorHaciaNParcial(d, n))
}

function hayMismoColorHaciaNParcial(d, n) {
	colorActual := colorActual()
	if (puedeMoverHaciaN(d, n)) {
		MoverN(d,n)
	}
	return (colorActual == colorActual())
}

//PRO: Devuelve el color que hay en la celda actual
//PRE: Tiene que existir 1 solo color en la actual
function colorActual() {
	color := minColor()
	ret := False
	foreach c in [minColor() .. maxColor()] {
		if (hayBolitas(c) && ret == False) {
			color := c
			ret := True
		}
	}
	return (color)
}

//PRE: Que se pueda mover n celdas en alguna d
procedure MoverN(d, n) {
	repeat (n) {
		Mover(d)
	}
}

//PRO: Si existen n bolitas del mismo color hacia d devuelve True
function hayNConsecutivasHacia(d, n) {
	color := colorActual()
	c := 0
	while (puedeMoverHaciaN(d, n-c) 
			&& hayElemento()
			&& hayMismoColorHaciaN(d, 1)
			&& c < n) {
		Mover(d)
		c := c + 1
		
	}
	return (hayElemento() && hayBolitas(color) && c==n)
}

/*
PRO: True si hay algun color de alguna bolita
PRE: Si existen bolitas tienen que ser de 1 solo color
*/
function hayElemento() {
	ret := True
	color := minColor()
	foreach c in [minColor() .. maxColor()] {
		if (hayBolitas(c) && ret == True) {
			ret := False
			color := c
		}
	}
	return (hayBolitas(color))
}

function ifElse(condicion,v,f){
	ret := f
	if (condicion) {
		ret := v
	}
   return(ret)
}